// Заголовочный файл с методами прямых и обратных преобразований для состояний

// Таблица подстановок для S-преобразования
int pi[16] = { 15, 9, 1, 7, 13, 12, 2, 8, 6, 5, 14, 3, 0, 11, 4, 10 };

/* Прямое S-преобразование (функция подстановки). Каждый полубайт из 64-битной входной последовательности 
 * заменяется соответствующим полубайтом из таблицы подстановок pi */
uint64_t S(const uint64_t &k) {
    uint64_t new_k = 0;
    int index = 0;
    for (int j = 15; j >= 0; j--) {
        index = (k >> (4 * j)) & 0xfLL;
        new_k = (new_k << 4) + pi[index];
    }
    return new_k;
}

// Обратная таблица подстановок для обратного S-преобразования
int pi_inv[16] = { 12, 2, 6, 11, 14, 9, 8, 3, 7, 1, 15, 13, 5, 4, 10, 0 };

/* Обратное S-преобразование (функция подстановки). Каждый полубайт из 64-битной входной последовательности
 * заменяется соответствующим полубайтом из обратной таблицы подстановок pi_inv */
uint64_t S_Inverted(const uint64_t &k) {
    uint64_t new_k = 0;
    int index = 0;
    for (int j = 15; j >= 0; j--) {
        index = (k >> (4 * j)) & 0xfLL;
        new_k = (new_k << 4) + pi_inv[index];
    }
    return new_k;
}

// Таблица перестановок для P-преобразования
int tau[16] = { 0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15 };

/* P-преобразование (функция перестановки). Для каждой пары полубайт из входной последовательности 
 * происходит замена одного полубайта другим */
uint64_t P (const uint64_t &k) {
    uint64_t new_k = 0;
    for (int i = 15; i >= 0; i--) {
        new_k = (new_k << 4) + ((k >> (4 * tau[i])) & 0xfLL);
    }
    return new_k;
}

// Бинарная матрица размером 16х16 для прямого L преобразования
int L_const[16] = { 0x3a22, 0x483b, 0x59e5, 0xac52,
                    0x8511, 0x248c, 0xbd7b, 0x56b1,
                    0x4b99, 0x1246, 0xcfac, 0xb3c9,
                    0x2cdd, 0x9123, 0x6e56, 0xc86d };

/* Прямое линейное L-преобразование. Представляет собой умножение 64-битного входного вектора на
 * бинарную матрицу A размером 64x64 бит */
uint64_t L(const uint64_t &k) {
    uint64_t new_k = 0;
    for (int i = 3; i >= 0; i--) {
        short block = 0;
        for (int j = 15; j >= 0; j--) {
            if ((((k >> (i * 16)) >> j) & 1) == 1)
                block = block ^ L_const[15 - j];
        }
        new_k = (new_k << 16) + (block & 0xffff);
    }
    return new_k;
}

// Обратная бинарная матрица размером 64x64 для обратного L-преобразования
int L_const_inv[16] = { 0xf50d, 0xdf5d, 0xddf8, 0x8dd7,
                        0xc17a, 0xac1d, 0xdacc, 0xcda0,
                        0x9c75, 0x59c2, 0x259e, 0xe257,
                        0x090e, 0xe09e, 0xee07, 0x7ee7 };

/* Обратное линейное L-преобразование. Представляет собой умножение 64-битного входного вектора на
 * бинарную матрицу, обратную бинарной матрице для прямого L-преобразования */
uint64_t L_Inverted(const uint64_t &k) {
    uint64_t new_k = 0;
    for (int i = 3; i >= 0; i--) {
        short block = 0;
        for (int j = 15; j >= 0; j--) {
            if ((((k >> (i * 16)) >> j) & 1) == 1)
                block = block ^ L_const_inv[15 - j];
        }
        new_k = (new_k << 16) + (block & 0xffff);
    }
    return new_k;
}

// Константы, используемые при формирования раундовых ключей
uint64_t roundKeyConstant[9] = { 0xc0164633575a9699LL, 0x925b4ef49a5e7174LL, 0x86a89cdcf673be26LL,
                                 0x1885558f0eaca3f1LL, 0xdcfc5b89e35e8439LL, 0x54b9edc789464d23LL,
                                 0xf80d49afde044bf9LL, 0x8cbbdf71ccaa43f1LL, 0xcb43af722cb520b9LL };